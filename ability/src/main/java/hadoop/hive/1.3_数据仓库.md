### 数据仓库
```sql
# 数据仓库四大特性：面向主题、集成的、稳定的、反映历史变化
# 输入系统：埋点日志产生的用户行为数据,javaee后台产生的业务数据
# 输出系统：报表系统,用户画像,推荐系统
# 数据采集：sqoop/flume/kafka/爬虫
# 数据存储：mysql/hdfs/hbase/redis/mongodb
# 数据计算：hive/spark/flink
# 数据查询：presto/druid/impala/kylin/es

# 数据仓库分层架构
ods(operation data store)：原始数据层,存放原始数据
dwd(data warehouse detail)：数仓明细层,对ods层数据进行数据清洗,改变存储格式,数据脱敏
dws(data warehouse service)：数仓服务层,对dwd层数据轻度聚合得到围绕某个主题的宽表,通常以日为粒度
ads(application data store)：应用数据层,按照各种业务指标生成统计报表
# 为什么要分层？
将复杂问题分解成多个步骤方便定位问题、中间层数据可以复用减少重复开发、统计数据与原始数据解耦
# 数据仓库和数据集市？
数据仓库是公司级的,数据集市是部门级的,有着更少的数据和主题

# 数据脱敏
手机、身份证、账号、邮箱、地址等私密信息的加密/掩码/截断/重排等,etl工具可以是sql/python/mr/rdd等
脱敏原则：尽可能保留脱敏前的有意义信息,且能最大程度上防止黑客破解
加密：通过udf将手机号码的4-11位都加1,然后4-7位和8-11位调换顺序,方便还原,安全程度取决于具体加密算法
掩码: 身份证变成320922******,只保留开头省市县信息且总长度不变,后期做用户归属地图表统计也不影响
重排：序号12345重排为54321,按照一定的顺序进行打乱,方便还原,但是也容易破解
截断：13811001111截断为138,舍弃必要信息保证数据模糊性,是比较常用的脱敏方法,但往往对生产不够友好

# 表的分类
实体表：对应实际业务对象,比如用户表、商品表
维度表：对应一些业务状态,也叫码表,比如地区信息、订单状态、商品分类、支付方式、审核状态
事务型事实表：随着业务发展不断产生的数据,且一旦生成就不再变化,比如订单详情、交易流水、操作日志、出入库记录
周期型事实表：随着业务发展不断产生的数据,且会随业务周期性变化,比如订单表、购物车表、退货流程表都会伴随状态更新字段
# 表的同步策略
实体表和维度表一般数据量都不大,可以每天存一份全量数据,即每日全量,有些固定不变的维度表可以只存一份
事务型事实表由于数据量巨大且不会变化,每天同步新增数据就行,即每日增量
周期型事实表由于数据量巨大且会变化,每日全量会很冗余,每日增量又不能反应数据变化,拉链表可以获取任意历史节点的快照数据

# 函数依赖
学号  姓名  系名  系主任  课程  分数
101  张三  经济系  李强  概率论  95
102  李四  法律系  王伟  劳动法  99
完全函数依赖：(学号+课程)能推断出分数,但是单独用学号或课程推断不出分数,所以分数完全依赖于(学号,课程)
部分函数依赖：(学号+课程)能推断出姓名,但是单独用学号也能推断出姓名,所以姓名部分依赖于(学号,课程)
传递函数依赖：学号能推断出系名,系名能推断出系主任,但是系主任推断不出学号,所以系主任传递依赖于学号
# 三大范式
设计数据库表结构的规范,优点是减少数据冗余,保证数据一致性,缺点是拆分成太多小表获取数据时需要join
第一范式：列不可分割
第二范式：不能存在部分函数依赖
第三范式：不能存在传递函数依赖

# 关系建模与维度建模
关系建模主要应用于OLTP系统,为了保证数据一致性并减少冗余,mysql大部分表都遵循三范式,多表join可以依靠强大的主键索引
维度建模主要应用于OLAP系统,处理大规模数据,跨表分析统计查询会造成多表关联性能很差,通常以某个事实表为中心,维度表围绕事实表进行解释
# 星型模型、雪花模型和星座模型
维度建模又分为星型模型和雪花模型,星型模型只有一层维度,雪花模型可能有多层维度,更接近3NF但是无法完全遵守因为3NF性能较差
星座模型和前两个模型区别在于事务表数量,星座模型是基于多个事实表的,也是数据仓库的常态,和前两个模型不冲突
至于选星型模型还是雪花模型,取决于性能优先还是灵活优先,整体来看更倾向于维度更少的星型模型,hadoop体系减少join就是减少shuffle,性能差距很大
 
# 用户行为分析
活跃主题：日活/周活(next_day)/月活(date_format)
沉默用户：只在下载当天启动过,且启动时间是在一周之前
select current_date,count(*) silent
from
    (select dev_id from dm_uv_detail_day where dt <= current_date group by dev_id having count(*) = 1 and min(dt) < date_sub(current_date, 7)) t1
group by current_date;
流失用户：最近一周都没有登录
select current_date,count(*) outflow 
from 
    (select dev_id from dm_uv_detail_day group by dev_id having max(dt) <= date_sub(current_date, 7)) t1
group by current_date;

# 电商报表
订单表和订单详情表区别：订单表有订单状态且周期型变化,订单详情表没有
```