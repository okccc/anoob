### 数据仓库
```bash
# 数据仓库四大特性：面向主题、集成的、稳定的、反映历史变化
# 输入系统：埋点日志产生的用户行为数据,javaee后台产生的业务数据
# 输出系统：报表系统,用户画像,推荐系统
# 数据采集：sqoop/flume/kafka/爬虫
# 数据存储：mysql/hdfs/hbase/redis/mongodb
# 数据计算：hive/spark/flink
# 数据查询：presto/druid/impala/kylin/es

# 数据仓库分层架构
ods(operation data store)：原始数据层,存放原始数据
dwd(data warehouse detail)：明细数据层,将ods层数据进行数据清洗(get_json_object/udf)/改变存储格式(orc/parquet)/数据脱敏(udf),etl工具可以是sql/python/mr/rdd等
dws(data warehouse service)：服务数据层,将dwd层数据轻度聚合,生成面向主题的宽表,通常以日为粒度,比如当日用户/当日商品/单日订单
ads(application data store)：应用数据层,按照各种业务指标聚合生成对应统计报表
# 为什么要分层？
将复杂问题分解成多个步骤方便定位问题 | 中间层数据可复用减少重复开发 | 统计数据与原始数据解耦
# 数据仓库和数据集市？
数据仓库是公司级的,数据集市是部门级的,有着更少的数据和主题

# tez引擎优点？
mr会将迭代任务的中间结果多次写入hdfs,而tez可以将有多个依赖的作业转换为一个作业,这样只需写一次hdfs从而大大提升计算性能

# udf解析日志的公共字段,udtf解析日志的事件详情
1554723616546|{  # 服务器时间
    "common": {  # 公共字段,一对一
        "os": "8.1.8",
        "v": "V2.3.1",
        "l": "en"
    },
    "ap": "gmail",
    "event": [{  # 事件详情,一对多
        "ett": "1554615312891",
        "en": "loading",  # 事件名称
        "kv": {
            "action": "1",
            "type": "2"
        }
    },{
        "ett": "1554645312891",
        "en": "favorite",
        "kv": {
            "uid": "1",
            "uname": "orc"
        }
    }]
}

# 数据脱敏
手机、身份证、账号、邮箱、地址等私密信息的加密/掩码/截断/重排等
脱敏原则：尽可能保留脱敏前的有意义信息,且能最大程度上防止黑客破解
加密：通过udf将手机号码的4-11位都加1,然后4-7位和8-11位调换顺序,方便还原,安全程度取决于具体加密算法
掩码: 身份证变成320922******,只保留开头省市县信息且总长度不变,后期做用户归属地图表统计也不影响
重排：序号12345重排为54321,按照一定的顺序进行打乱,方便还原,但是也容易破解
截断：13811001111截断为138,舍弃必要信息保证数据模糊性,是比较常用的脱敏方法,但往往对生产不够友好
```

### 用户行为分析
```sql
-- 活跃用户：日活/周活(next_day)/月活(date_format),统计设备id
create external table dws_uv_detail_day(
    mid_id string COMMENT '设备唯一标识',
    user_id string COMMENT '用户标识', 
    version_code string COMMENT '程序版本号', 
    version_name string COMMENT '程序版本名', 
    lang string COMMENT '系统语言', 
    source string COMMENT '渠道号', 
    os string COMMENT '安卓系统版本', 
    area string COMMENT '区域', 
    model string COMMENT '手机型号', 
    brand string COMMENT '手机品牌', 
    sdk_version string COMMENT 'sdkVersion', 
    gmail string COMMENT 'gmail', 
    height_width string COMMENT '屏幕宽高',
    app_time string COMMENT '客户端日志产生时的时间',
    network string COMMENT '网络模式',
    lng string COMMENT '经度',
    lat string COMMENT '纬度'
)  COMMENT '每日活跃设备'
partitioned by(dt string)
stored as parquet
location '/warehouse/dws/dws_uv_detail_day';

-- 新增用户：日活表left join新增表,新增表中mid为空的即为新增用户
create external table dws_new_mid_day(
    mid_id string COMMENT '设备唯一标识',
    user_id string COMMENT '用户标识', 
    version_code string COMMENT '程序版本号', 
    version_name string COMMENT '程序版本名', 
    lang string COMMENT '系统语言', 
    source string COMMENT '渠道号', 
    os string COMMENT '安卓系统版本', 
    area string COMMENT '区域', 
    model string COMMENT '手机型号', 
    brand string COMMENT '手机品牌', 
    sdk_version string COMMENT 'sdkVersion', 
    gmail string COMMENT 'gmail', 
    height_width string COMMENT '屏幕宽高',
    app_time string COMMENT '客户端日志产生时的时间',
    network string COMMENT '网络模式',
    lng string COMMENT '经度',
    lat string COMMENT '纬度',
    create_date  string  comment '创建时间' 
)  COMMENT '每日新增设备'
stored as parquet
location '/warehouse/dws/dws_new_mid_day/';
-- 追加数据
insert into table dws_new_mid_day
select t1.*,current_date 
from dws_uv_detail_day t1 
left join dws_new_mid_day t2 on t1.mid_id = t2.mid_id 
where t1.dt=current_date and t2.mid_id is null;

-- 留存用户：日活表join新增表前1/3/7/15天
create external table dws_user_retention_day (
    mid_id string COMMENT '设备唯一标识',
    user_id string COMMENT '用户标识', 
    version_code string COMMENT '程序版本号', 
    version_name string COMMENT '程序版本名', 
    lang string COMMENT '系统语言', 
    source string COMMENT '渠道号', 
    os string COMMENT '安卓系统版本', 
    area string COMMENT '区域', 
    model string COMMENT '手机型号', 
    brand string COMMENT '手机品牌', 
    sdk_version string COMMENT 'sdkVersion', 
    gmail string COMMENT 'gmail', 
    height_width string COMMENT '屏幕宽高',
    app_time string COMMENT '客户端日志产生时的时间',
    network string COMMENT '网络模式',
    lng string COMMENT '经度',
    lat string COMMENT '纬度',
   create_date    string  comment '设备新增时间',
   retention_day  int comment '截止当前日期留存天数'
)  COMMENT '每日留存用户'
PARTITIONED BY (dt string)
stored as parquet
location '/warehouse/gmall/dws/dws_user_retention_day/';
-- 插入数据
insert overwrite table dws_user_retention_day partition(dt="2019-02-11")
select t2.*,1 retention_day 
from dws_uv_detail_day t1 join dws_new_mid_day t2 on t1.mid_id = t2.mid_id 
where t1.dt=current_date and t2.create_date = date_add(current_date,-1);  -- 1/3/7/15日留存分别减1/3/7/15

-- 沉默用户：只在下载当天启动过,且启动时间是在7天前
insert into table ads_silent_count
select current_date,count(*) silent
from
    (select dev_id from dws_uv_detail_day where dt <= current_date group by dev_id having count(*) = 1 and min(dt) < date_sub(current_date, 7)) t1
group by current_date;

-- 流失用户：最近7天都没有登录
insert into table ads_wastage_count
select current_date,count(*) wastage 
from 
    (select dev_id from dws_uv_detail_day group by dev_id having max(dt) <= date_sub(current_date, 7)) t1
group by current_date;

-- 本周回流用户：本周活跃 - 本周新增 - 上周活跃
insert into table ads_back_count
select 
   '2019-02-20' dt,
   concat(date_add(next_day('2019-02-20','MO'),-7),'_',date_add(next_day('2019-02-20','MO'),-1)) wk_dt,
   count(*)
from 
(
    select t1.mid_id
    from 
    (
        select mid_id
        from dws_uv_detail_wk
        where wk_dt = concat(date_add(next_day('2019-02-20','MO'),-7),'_',date_add(next_day('2019-02-20','MO'),-1))
    ) t1
    left join
    (
        select mid_id
        from dws_new_mid_day
        where create_date <= date_add(next_day('2019-02-20','MO'),-1) and create_date >= date_add(next_day('2019-02-20','MO'),-7)
    ) t2 on t1.mid_id = t2.mid_id
    left join
    (
        select mid_id
        from dws_uv_detail_wk
        where wk_dt = concat(date_add(next_day('2019-02-20','MO'),-7*2),'_',date_add(next_day('2019-02-20','MO'),-7-1))
    ) t3 on t1.mid_id = t3.mid_id
    where t2.mid_id is null and t3.mid_id is null
) t4
group by '2019-02-20',
         concat(date_add(next_day('2019-02-20','MO'),-7),'_',date_add(next_day('2019-02-20','MO'),-1));
```

### 电商业务分析
```sql
# 表的分类
实体表：对应实际业务对象,比如用户表、商品表
维度表：对应一些业务状态,也叫码表,比如地区信息、订单状态、商品分类、支付方式、审核状态
事务型事实表：随着业务发展不断产生的数据,且一旦生成就不再变化,比如订单详情、交易流水、操作日志、出入库记录
周期型事实表：随着业务发展不断产生的数据,且会随业务周期性变化,比如订单表、购物车表、退货流程表都会伴随状态更新字段
# 同步策略
实体表和维度表一般数据量都不大,可以每天存一份全量数据,即每日全量,有些固定不变的维度表可以只存一份
事务型事实表由于数据量巨大且不会变化,每天同步新增数据就行,即每日增量
周期型事实表由于数据量巨大且会变化,每日全量会很冗余,每日增量又不能反应数据变化,拉链表可以获取任意历史节点的快照数据

# 函数依赖
学号  姓名  系名  系主任  课程  分数
101  张三  经济系  李强  概率论  95
102  李四  法律系  王伟  劳动法  99
完全函数依赖：(学号+课程)能推断出分数,但是单独用学号或课程推断不出分数,所以分数完全依赖于(学号,课程)
部分函数依赖：(学号+课程)能推断出姓名,但是单独用学号也能推断出姓名,所以姓名部分依赖于(学号,课程)
传递函数依赖：学号能推断出系名,系名能推断出系主任,但是系主任推断不出学号,所以系主任传递依赖于学号
# 三大范式
设计数据库表结构的规范,优点是减少数据冗余,保证数据一致性,缺点是拆分成太多小表获取数据时需要join
第一范式：列不可分割
第二范式：不能存在部分函数依赖
第三范式：不能存在传递函数依赖

# 关系建模与维度建模
关系建模主要应用于OLTP系统,为了保证数据一致性并减少冗余,mysql大部分表都遵循三范式,多表join可以依靠强大的主键索引
维度建模主要应用于OLAP系统,处理大规模数据,跨表分析统计查询会造成多表关联性能很差,通常以某个事实表为中心,维度表围绕事实表进行解释
# 星型模型、雪花模型和星座模型
维度建模又分为星型模型和雪花模型,星型模型只有一层维度,雪花模型可能有多层维度,更接近3NF但是无法完全遵守因为3NF性能较差
星座模型和前两个模型区别在于事务表数量,星座模型是基于多个事实表的,也是数据仓库的常态,和前两个模型不冲突
至于选星型模型还是雪花模型,取决于性能优先还是灵活优先,整体来看更倾向于维度更少的星型模型,hadoop体系减少join就是减少shuffle,性能差距很大

-- 订单表和订单详情表区别：订单表有订单状态且周期型变化,订单详情表没有
```