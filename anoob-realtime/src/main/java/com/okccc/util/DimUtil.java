package com.okccc.util;

/**
 * @Author: okccc
 * @Date: 2023/4/8 09:37:54
 * @Desc:
 *
 * 计算机存储结构中,低一层的存储器都可以看成高一层的存储器的缓存,比如cache是内存的缓存,内存是硬盘的缓存,硬盘是网络的缓存
 * 缓存容量是固定的,应该只放经常访问的热数据,根据过去的访问时间进行排序删除最老的元素,LRUCache(Least Recently Used)是最常用的缓存策略
 *
 * 缓存选型：
 * 堆缓存(HashMap)：访问本地缓存路径更短性能更好,但是不便于维护,因为本地缓存的数据其它进程无法使用,LRUCache继承了LinkedHashMap
 * 独立缓存(Redis)：创建连接和网络IO会略微降低性能,但是便于维护,因为独立缓存的数据可以被多个进程复用(推荐)
 *
 * 旁路缓存：先查询redis缓存,命中直接返回,没有命中再去查询mysql/hbase数据库同时将结果写入缓存
 * 注意事项：1.缓存要设置过期时间,防止冷数据常驻缓存浪费资源 2.数据库update/delete数据时要及时清除失效缓存
 *
 * redis面试题：数据更新,先更新数据库还是先更新缓存？
 * a.先更新数据库,再删除缓存(常用)：缓存刚好失效,A查询缓存未命中去数据库查询旧值,B更新数据库并让缓存失效,A将旧数据写入缓存,导致脏数据
 * 读操作必须先于写操作进入数据库,又晚于写操作更新缓存才会导致该情况发生,然而实际上数据库的写操作比读操作慢很多还得锁表,所以发生概率极低
 * b.先删除缓存,再更新数据库：A删除缓存,B查询缓存未命中去数据库查询旧值并写入缓存,A更新数据库,导致脏数据
 * c.先更新数据库,再更新缓存：A更新数据为V1,B更新数据为V2,B更新缓存为V2,A更新缓存为V1,A先操作但是网络延迟B先更新了缓存,导致脏数据
 * d.先更新缓存,再更新数据库：如果缓存更新成功但数据库异常导致回滚,而缓存是无法回滚的,导致数据不一致(不考虑)
 */
